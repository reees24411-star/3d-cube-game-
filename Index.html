<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover"/>
<title>Shooter Arena — GitHub Pages Ready</title>
<style>
  html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; -webkit-font-smoothing:antialiased; background:#111; color:#eee;}
  #ui {
    position: absolute; z-index: 10; left: 12px; top: 12px;
    background: rgba(0,0,0,0.35); padding: 10px; border-radius: 8px;
    backdrop-filter: blur(4px);
  }
  #ui strong { display:block; font-size:14px; }
  #hud { position: absolute; right:12px; top:12px; z-index:10; background: rgba(0,0,0,0.35); padding:10px; border-radius:8px; text-align:right;}
  #canvas-wrap { width:100%; height:100%; touch-action: none; }
  .mobile-controls {
    position: absolute; z-index: 11; left: 12px; bottom: 12px; display:flex; gap:8px;
    user-select:none;
  }
  .btn {
    width:64px; height:64px; border-radius:10px; background:rgba(255,255,255,0.06); display:flex; align-items:center; justify-content:center; color:#fff; font-weight:700;
    box-shadow: 0 6px 14px rgba(0,0,0,0.6); font-size:18px;
    -webkit-tap-highlight-color: transparent;
  }
  .btn:active { transform: translateY(2px); }
  .fire { width:86px; height:86px; border-radius:50%; background: linear-gradient(180deg, rgba(255,60,60,0.9), rgba(200,0,0,0.9)); font-size:18px; }
  #message {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:12; color:#fff; background:rgba(0,0,0,0.55); padding:20px; border-radius:12px; display:none;
  }
  a.link { color:#9cf; text-decoration:none; }
  @media (min-width:900px) { .mobile-controls { display:none; } }
  @media (max-width:899px) { #ui, #hud { font-size:14px; } }
</style>
</head>
<body>
  <div id="canvas-wrap"></div>

  <div id="ui">
    <strong>Shooter Arena</strong>
    <div>Controls: WASD / Arrows to move • Click / Tap to shoot</div>
    <div style="margin-top:6px">Mobile: use on-screen buttons</div>
  </div>

  <div id="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Health: <span id="health">100</span></div>
    <div style="margin-top:6px"><button id="restartBtn">Restart</button></div>
  </div>

  <div class="mobile-controls" id="mobile-controls" style="display:none;">
    <div style="display:flex;flex-direction:column;gap:8px">
      <div class="btn" id="upBtn">↑</div>
      <div style="display:flex;gap:8px">
        <div class="btn" id="leftBtn">←</div>
        <div class="btn" id="downBtn">↓</div>
        <div class="btn" id="rightBtn">→</div>
      </div>
    </div>
    <div style="margin-left:10px">
      <div class="fire" id="fireBtn">FIRE</div>
    </div>
  </div>

  <div id="message"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
/*
  Shooter Arena — single-file
  - Player is a capsule (camera sits at head)
  - Enemies spawn in front and move to player
  - Click/tap to shoot bullets (ray direction from camera)
  - Mobile UI provided
  - Save as index.html and host on GitHub Pages
*/

// Basic THREE setup
const canvasWrap = document.getElementById('canvas-wrap');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.6, 0); // player eye height

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
canvasWrap.appendChild(renderer.domElement);

// lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(5,10,5);
dir.castShadow = true;
scene.add(dir);

// ground
const groundMat = new THREE.MeshStandardMaterial({ color: 0x2b2b2b, roughness: 0.9 });
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// simple arena walls (visual)
const wallMat = new THREE.MeshStandardMaterial({ color: 0x151515 });
const wall1 = new THREE.Mesh(new THREE.BoxGeometry(200,10,2), wallMat);
wall1.position.set(0,5,-100);
scene.add(wall1);

// player state
const player = {
  pos: new THREE.Vector3(0,0,0),
  vel: new THREE.Vector3(),
  speed: 6,
  health: 100,
  score: 0,
  canShoot: true,
  shootCooldown: 0.18 // seconds
};

// camera follows player position
function updateCamera() {
  camera.position.set(player.pos.x, player.pos.y + 1.6, player.pos.z);
  // camera rotation controlled by mouse (below)
}

// basic pointer control for look
let yaw = 0, pitch = 0;
let isPointerDown = false;
let prevTouch = null;
function handlePointerMove(clientX, clientY) {
  const w = window.innerWidth, h = window.innerHeight;
  const nx = (clientX / w - 0.5) * 2;
  const ny = (clientY / h - 0.5) * 2;
  // map to small rotation influence
  // smoother by lerp for feel
  const targetYaw = -nx * Math.PI * 0.5;
  const targetPitch = -ny * Math.PI * 0.25;
  yaw += (targetYaw - yaw) * 0.12;
  pitch += (targetPitch - pitch) * 0.12;
  pitch = Math.max(-Math.PI/4, Math.min(Math.PI/4, pitch));
  camera.rotation.set(pitch, yaw, 0, 'ZYX');
}

// movement controls
const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// mobile control flags
const mobile = { up:false, down:false, left:false, right:false, fire:false };
function applyInput(dt) {
  let dir = new THREE.Vector3();
  if (keys['w'] || keys['arrowup'] || mobile.up) dir.z -= 1;
  if (keys['s'] || keys['arrowdown'] || mobile.down) dir.z += 1;
  if (keys['a'] || keys['arrowleft'] || mobile.left) dir.x -= 1;
  if (keys['d'] || keys['arrowright'] || mobile.right) dir.x += 1;
  if (dir.lengthSq() > 0) {
    dir.normalize();
    // rotate direction by camera yaw
    const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const right = new THREE.Vector3(forward.z, 0, -forward.x);
    const move = forward.clone().multiplyScalar(-dir.z).add(right.clone().multiplyScalar(dir.x));
    move.normalize();
    player.pos.add(move.multiplyScalar(player.speed * dt));
  }
  // fire
  if (mobile.fire && player.canShoot) doShoot();
}

// bullets pool
const bullets = [];
const bulletPool = [];
const BULLET_SPEED = 30;
function spawnBullet(origin, dir) {
  let b;
  if (bulletPool.length) b = bulletPool.pop();
  else {
    const g = new THREE.SphereGeometry(0.08,8,8);
    const m = new THREE.MeshStandardMaterial({ emissive:0xffddaa, emissiveIntensity:0.8, color:0xffffaa });
    b = new THREE.Mesh(g,m);
    b.castShadow = true;
    b.userData.alive = false;
    scene.add(b);
  }
  b.position.copy(origin);
  b.userData.dir = dir.clone();
  b.userData.alive = true;
  bullets.push(b);
}

// enemies pool
const enemies = [];
const enemyPool = [];
function spawnEnemy(pos) {
  let en;
  if (enemyPool.length) en = enemyPool.pop();
  else {
    const g = new THREE.SphereGeometry(0.6, 12, 12);
    const m = new THREE.MeshStandardMaterial({ color: 0xee4444, metalness:0.1, roughness:0.8 });
    en = new THREE.Mesh(g,m);
    scene.add(en);
  }
  en.position.copy(pos);
  en.userData.speed = 1 + Math.random()*1.5;
  en.userData.alive = true;
  enemies.push(en);
}

// shooting
const raycaster = new THREE.Raycaster();
function doShoot() {
  player.canShoot = false;
  setTimeout(()=> player.canShoot = true, player.shootCooldown*1000);
  // spawn bullet from camera position
  const origin = camera.position.clone();
  // direction from camera forward
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  spawnBullet(origin, forward);
  // small visual muzzle flash (optional)
}

// spawn logic
let spawnTimer = 0;
function spawnWave(dt) {
  spawnTimer -= dt;
  if (spawnTimer <= 0) {
    spawnTimer = Math.max(0.6, 2 - Math.min(1.5, Math.floor(player.score/10))*0.08); // faster over time
    // spawn enemy at random around player, far in z direction
    const angle = Math.random()*Math.PI*2;
    const radius = 16 + Math.random()*14;
    const x = player.pos.x + Math.cos(angle)*radius;
    const z = player.pos.z + Math.sin(angle)*radius - 4;
    const y = 0.6;
    spawnEnemy(new THREE.Vector3(x,y,z));
  }
}

// collisions & updates
function updateEntities(dt) {
  // bullets move
  for (let i = bullets.length-1; i >= 0; --i) {
    const b = bullets[i];
    if (!b.userData.alive) { bullets.splice(i,1); continue; }
    b.position.add(b.userData.dir.clone().multiplyScalar(BULLET_SPEED * dt));
    // lifespan cull (distance from player)
    if (b.position.distanceTo(player.pos) > 120) { b.userData.alive = false; scene.remove(b); bulletPool.push(b); bullets.splice(i,1); continue; }
    // check enemy hit
    for (let j = enemies.length-1; j >= 0; --j) {
      const en = enemies[j];
      if (!en.userData.alive) { enemies.splice(j,1); continue; }
      const dist = b.position.distanceTo(en.position);
      if (dist < 0.7) {
        // hit!
        en.userData.alive = false;
        scene.remove(en); enemyPool.push(en); enemies.splice(j,1);
        // remove bullet
        b.userData.alive = false;
        scene.remove(b); bulletPool.push(b); bullets.splice(i,1);
        // score
        player.score += 1;
        document.getElementById('score').textContent = player.score;
        // small explosion (visual)
        spawnExplosion(en.position);
        break;
      }
    }
  }

  // enemies move toward player
  for (let i = enemies.length-1; i >= 0; --i) {
    const en = enemies[i];
    if (!en.userData.alive) { enemies.splice(i,1); continue; }
    const dir = player.pos.clone().sub(en.position);
    dir.y = 0;
    const dist = dir.length();
    dir.normalize();
    en.position.add(dir.multiplyScalar(en.userData.speed * dt * (1 + player.score*0.01)));
    // if reach player
    if (en.position.distanceTo(player.pos) < 1.2) {
      // damage and remove
      player.health -= 12 + Math.floor(Math.random()*6);
      if (player.health < 0) player.health = 0;
      document.getElementById('health').textContent = player.health;
      // remove enemy
      en.userData.alive = false;
      scene.remove(en); enemyPool.push(en); enemies.splice(i,1);
      spawnExplosion(en.position);
      if (player.health <= 0) {
        gameOver();
      }
    }
  }
}

// simple explosion visual
const explosions = [];
function spawnExplosion(pos) {
  const g = new THREE.SphereGeometry(0.3,8,8);
  const m = new THREE.MeshStandardMaterial({ emissive:0xffaa55, emissiveIntensity:1, transparent:true, opacity:0.95 });
  const s = new THREE.Mesh(g,m);
  s.position.copy(pos);
  s.userData.life = 0.6;
  scene.add(s);
  explosions.push(s);
}

// update explosions
function updateExplosions(dt) {
  for (let i = explosions.length-1; i >= 0; --i) {
    const e = explosions[i];
    e.userData.life -= dt;
    e.scale.addScalar(dt*3);
    e.material.opacity = Math.max(0, e.userData.life / 0.6);
    if (e.userData.life <= 0) {
      scene.remove(e);
      explosions.splice(i,1);
    }
  }
}

// game over
const msg = document.getElementById('message');
let running = true;
function gameOver() {
  running = false;
  msg.style.display = 'block';
  msg.innerHTML = `<h2 style="margin:0 0 8px 0">You died</h2><div>Score: ${player.score}</div><div style="margin-top:10px"><button id="playAgain">Play Again</button></div>`;
  document.getElementById('playAgain').addEventListener('click', resetGame);
}

// reset
function resetGame() {
  // clean pools
  bullets.forEach(b=>{ if (b.parent) scene.remove(b); });
  bullets.length = 0;
  enemies.forEach(e=>{ if (e.parent) scene.remove(e); });
  enemies.length = 0;
  explosions.forEach(x=>{ if (x.parent) scene.remove(x); });
  explosions.length = 0;
  player.health = 100;
  player.score = 0;
  document.getElementById('score').textContent = '0';
  document.getElementById('health').textContent = '100';
  player.pos.set(0,0,0);
  yaw = 0; pitch = 0;
  running = true;
  msg.style.display = 'none';
}

// hook up restart button
document.getElementById('restartBtn').addEventListener('click', resetGame);

// input: mouse and touch
renderer.domElement.addEventListener('pointerdown', (e) => {
  isPointerDown = true;
  if (e.pointerType === 'touch') prevTouch = { x: e.clientX, y: e.clientY };
  // if click/tap on right half -> shoot
  // small region heuristic: if click is near center or right half, shoot; otherwise start look control
  if (e.clientX > window.innerWidth*0.4) {
    doShoot();
  }
});
renderer.domElement.addEventListener('pointerup', (e) => {
  isPointerDown = false;
  prevTouch = null;
});
renderer.domElement.addEventListener('pointermove', (e) => {
  // mobile: dragging anywhere rotates view
  if (isPointerDown) handlePointerMove(e.clientX, e.clientY);
});

// mouse click for desktop shooting
renderer.domElement.addEventListener('click', (e) => {
  // if user clicked UI buttons, ignore (they're above canvas)
  // click to shoot
  if (e.pointerType === 'mouse') doShoot();
});

// mobile controls: show if small screen
function setupMobileUI() {
  const mc = document.getElementById('mobile-controls');
  if (window.innerWidth < 900) {
    mc.style.display = 'flex';
    const mapBtn = (id, key) => {
      const el = document.getElementById(id);
      el.addEventListener('touchstart', (e)=>{ e.preventDefault(); mobile[key]=true; });
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); mobile[key]=false; });
      el.addEventListener('mousedown', ()=> mobile[key]=true);
      el.addEventListener('mouseup', ()=> mobile[key]=false);
      el.addEventListener('mouseleave', ()=> mobile[key]=false);
    };
    mapBtn('upBtn','up'); mapBtn('downBtn','down'); mapBtn('leftBtn','left'); mapBtn('rightBtn','right');
    const fireBtn = document.getElementById('fireBtn');
    fireBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); mobile.fire=true; });
    fireBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); mobile.fire=false; });
    fireBtn.addEventListener('mousedown', ()=> mobile.fire=true);
    fireBtn.addEventListener('mouseup', ()=> mobile.fire=false);
    fireBtn.addEventListener('mouseleave', ()=> mobile.fire=false);
  } else {
    mc.style.display = 'none';
  }
}
setupMobileUI();
window.addEventListener('resize', ()=> { renderer.setSize(window.innerWidth,window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); setupMobileUI(); });

// simple physics tick
let last = performance.now() / 1000;
function animate() {
  const now = performance.now() / 1000;
  const dt = Math.min(0.05, now - last);
  last = now;
  if (running) {
    // input
    applyInput(dt);
    // spawn
    spawnWave(dt);
    // entities
    updateEntities(dt);
    updateExplosions(dt);
    // camera follow
    updateCamera();
  }
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

// small instructions: ensure it runs on mobile
// expose basic debug to console
console.log('Shooter Arena loaded. Use WASD or on-screen buttons. Click/tap to shoot.');

// Make sure UI shows initial values
document.getElementById('score').textContent = '0';
document.getElementById('health').textContent = '100';
</script>
</body>
</html>
